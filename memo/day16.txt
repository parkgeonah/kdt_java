day16(java 14일차)

복습 -> 추상클래스 -> 인터페이스 -> 어댑터클래스 -> 내부클래스 -> 익명클래스

0. 복습
1) 상속
	class 부모클래스명{
		// 부모멤버
	}

	class 자식클래스명 extends 부모클래스명{
		// 부모멤버, 자식멤버
	}

2) 접근제한자
	public		클래스, 필드, 생성자, 메소드 		없음
	protected	필드, 생성자, 메소드 		같은 패키지거나 상속받은 자식 객체만 사용가능
	(default)	클래스, 필드, 생성자, 메소드 		같은 패키지
	private		필드, 생성자, 메소드			같은 클래스

3)setter, getter
	private 접근제한자를 사용하여 필드에 직접 접근하지 못하도록 하고 대신 getter, setter메소드를
	이용하여 값을 읽고 쓸 수 있다
	이클립스 단축키: alt + shift + s + r
	setter 매개변수로만 값을 저장하는 메소드
	리턴타입 void
	메소드명 setter에서 set + 필드이름(첫문자는 대문자)
	매개변수 필드의 타입으로 설정
	
	getter 값을 외부로 반환(리턴)할 때 사용하는 메소드
	리턴타입 필드의 타입
	메소드명 getter에서 get+ 필드이름(첫문자는 대문자)
	리턴값 필드 값

4) 캡슐화(Encapsulation)
	객체지향 프로그래밍(OOP) 핵심 개념 중 하나
	데이터(필드)와 메소드를 하나의 단위로 묶고, 외부에서 직접 접근할 수 없도록 보호하는 것을 의미한다
	- 데이터 보호
	- 인터페이스 제공
	- 코드 유지보수성

5) 무결성(Integrity)
	데이터를 올바르고 일관성있게 유지하는 것을 의미
	캡슐화를 통해 데이터를 보호하고 유효성 검사를 통해 무결성을 보장할 수 있다
	- private 접근제한자 : 데이터를 직접 수정하지 못하게 보호
	- getter, setter : 데이터를 읽거나 쓸 때 유효성 검사를 통해 잘못된 값이 설정되지 않도록 함
	- 데이터의 상태를 변경할 때 조건을 부여해 항상 일관된 상태를 유지

6) 캐스팅(up casting, down casting)
	★부모값을  자식 타입으로 형 변환시 오류 발생
	자식클래스 참조변수 = new 부모클래스명(); (잘못된 다운캐스팅)
	★자식클래스 타입의 객체는 부모 클래스 타입도 동시에 갖는다

	up casting : 자식값을 부모 타입으로 형변환(자동 타입 변환)
	부모클래스 참조변수 = new 자식클래스생성자();

	down casting : 이미 up casting된 객체를 자식타입으로 형 변환(강제 타입 변환)
			반드시 타입을 확인 후 사용 (instanceof)
	((자식클래스))업캐스팅된객체명).자식클래스의멤버메소드();
	((자식클래스)new 자식클래스생성자()).자식클래스의멤버메소드();

--------------------------------------------------------------------------------------------------
1. 추상 클래스
	클래스를 구성하는 멤버 중 추상 메소드가 존재한다는 의미

1) 추상 메소드
	메소드를 선언만 하고 구현을 하지 않은 것을 추상 메소드라고 한다(미완성된 메소드)
	abstract 키워드를 사용한다
	마지막에 반드시 ;(세미콜론)을 써야한다

일반메소드 정의
	접근제한자 리턴타입 메소드명(자료형 매개변수){
		// 실행할문장;
		return 리턴값;
	}

추상 메소드 정의
	접근제한자 abstract 리턴타입 메소드명(자료형 매개변수);

2) 추상클래스
	abstract 키워드가 붙은 클래스는 추상 클래스이며
	추상 메소드가 한 개 이상 있는 클래스는 반드시 추상 클래스로 선언해야한다(미완성된 클래스)

- 추상클래스 선언
	abstract class 클래스명{
		abstract 리턴타입 메소드명(자료형 매개변수);
		// 일반 메소드도 선언 가능
	}
	
	abstract 키워드를 사용한다
	객체화 시킬 수 없다

	※ 미완성된 메소드(추상메소드)는 상속받은 자식 클래스에서 반드시 재정의하여 구현을 해야만
	해당 클래스를 객체화 할 수 있다
	그러므로 [강제성]을 부여하기 위해서 추상 메소드로 선언한다	

3) 추상 클래스를 사용하는 이유
	공통되는 속성과 행위를 추상화하여 부모 클래스를 만드는데 반드시 모든 자식클래스에서 구현해야하는 메소드가 있다면
	추상 메소드로 선언하는게 좋다
	추상 클래스를 상속받은 자식 클래스는 추상 메소드를 오버라이딩 하지 않으면 오류가 발생하므로 [강제성]이 생기게 된다
	만약 부모 클래스에서 메소드를 구현한다면 강제성이 없으므로 자식 클래스를 만드는 개발자가 재정의하지 않고
	그냥 넘어갈 수 있다


2. 인터페이스(interface)
	일종의 추상클래스지만 클래스라고 부르지 않으면 추상화의 정도가 높다
	멤버로는 상수, 추상메소드만 가질 수 있다
	인터페이스는 객체화 할 수 없다
	인터페이스는 다른 클래스에서 구현(implements)해서 사용한다
	구현할 때는 implements 키워드를 사용한다

1) 인터페이스 선언
	interface 인터페이스명{
		// 상수, 추상메소드
	}

2) 인터페이스의 멤버
	모든 변수에는 public static final이다(생략해도 자동으로 붙음)
	모든 메소드느느 public abstract이다(생략해도 자동으로 붙음)

+) 일반클래스 vs 추상클래스 vs 인터페이스 추상화의 정도
- 일반클래스
	멤버: 필드(인스턴스변수, 상수, 스태틱변수), 메소드(인스턴스메소드, 스태틱메소드)
	가장 구체적
	세부 구현이 모두 포함됨
	추상화의 정도가 낮음

	class Dog{
		void sound(){
			syso("멍멍");
		}
	}

- 추상클래스
	멤버: 필드(인스턴스변수, 스태틱변수, 상수), 메소드(인스턴스메소드, 스태틱메소드, 추상메소드)
	일부 구현만 제공
	공통적인 부분을 추상화하지만, 세부 구현도 일부 포함
	추상화의 정도는 중간

	abstract class Animal{
		
		abstract void sound();
		void eat(){
			syso("먹습니다")
		}
	}

- 인터페이스
	멤버: 상수, 추상메소드
	구현없이 완전 추상적
	구체적인 세부사항이 전혀 포함하지 않음
	추상화의 정도가 가장 높다

	interface Animal[
		public abstract void eat();
		void selep();
	}

+) 추상화
	중요한 기능(부분)만 보여주고 복잡한 내부 동작은 숨기는 것을 의미
	ATM => 출금, 입금 등
	자동차 => 핸들, 가속페달, 브레이크 페달 사용

+) 프로그래밍에서의 추상화
	필요한 것만 보여줌 : 클래스나 메소드를 설계할 때 어떻게 동작되는지는 숨기고 무엇을 할 수 있는지만 정의
	
	동물 클래스 => 동물은 소리를 낸다는 공통동작이 있다. 구체적으로 어떤 소리를 내는지는 동물마다 다르다
	추상화를 사용하면 소리를 낸다는 동작만 정의하고 구체적인 소리는 각 동물이 구현하도록 만들어준다


3) 클래스의 상속과 인터페이스의 구현
1. 클래스는 단일 상속만 가능하며 인터페이스는 다중 구현이 가능하다
(1) 클래스 단일 상속
	클래스는 하나의 클래스만 상속받을 수 있다
	다중 상속은 충돌문제를 일으킬 수 있기 때문이다
	ex) 동일한 이름의 메소드를 여러 부모 클래스가 제공하는 경우 어떤 메소드를 호출해야할 지 모호함 발생

(2) 인터페이스는 다중 구현
	여러 인터페이스를 동시에 구현할 수 있다
	인터페이스의 메소드는 구현이 없기 때문에 충돌 위험이 없다
	구현 클래스에서 메소드를 정의하기 때문에 충돌 문제를 피할 수 있다


2. 인터페이스는 인터페이스를 상속 할 수 있다
	인터페이스끼리는 상속이 가능하며 다중 상속도 가능하다
	상속받은 인터페이스 모두 포함되며 구현하는 클래스는 모든 메소드를 구현해야 한다(오버라이딩)

3. 상속과 구현은 별개이다
	클래스 상속과 인터페이스 구현을 동시에 사용할 수 있다
	하나의 클래스가 다른 클래스를 상속받으면서 동시에 여러 인터페이스를 구현하는 것이 가능하다

4) 인터페이스르 사용하는 이유
	여러 클래스에서 선언할 멤버들을 일관되게 하기 위해 사용한다(표준화)
	관계없는 클래스들을 그룹화 시킬 수 있다(마커 인터페이스)
	

5) 다중 상속
	여러 부모클래스를 상속하는 것을다중 상속이라고 한다
	java는 모호성 때문에 다중 상속을 지원하지 않는다
	하지만 jdk8버전(2014년 출시)부터는 인터페이스 default 메소드, static 메소드, private 메소드를 만드는 것을 허용하고 있다
	(특정 메소드의 구현을 허용한다)
	여러개를 구현(상속)할 수 있는 인터페이스의 특징 때문에 다중상속을 지원하는 것과 다름이 없다
	
인터페이스에 추가된 기능
- default 메소드를 선언할 수 있다
	default 리턴타입 메소드명(자료형 매개변수){
	 	//실행할코드;
	}

- static 메소드를 선언할 수 있다
	static 리턴타입 메소드명(자료형 매개변수){
		//실행할코드;
	} 

- private 메소드를 선언할 수 있다(jdk9버전부터 사용 가능하다
	private 리턴타입 메소드명(자료형 매개변수){
		//실행할코드;
	}

6) 모호성(ambiguity)
	하나의 자식이 여러 부모를 상속받을 때 서로 다른 부모클래스에 동일한 멤버가 있다면
	어떤 부모의 멤버인지 알 수 없다

모호성 해결방법
	- 두개의 인터페이스에 같은 메소드가 선언되어잇는 경우(메소드명, 매개변수, 리턴타입이 같은 메소드)
	=> 자식클래스에서 메소드 재정의 하여 사용한다

	- 부모클래스의 메소드와 인터페이스의 메소드의 이름과 매개변수가 같은 경우
	=> 부모클래스의 메소드가 사용된다
		구현하는 인터페이스보다 상속받는 부모 클래스의 우선순위가 높기 때문이다

	
+) 인터페이스 메모리 영역
	인터페이스 자체		new로 생성 불가하므로 메로리에 객체로 올라가지 않음
	상수(stahitc final)	method 영역
	디폴트 메소드(default)	구현 되는 클래스의 인스턴스와 함께 사용됨
	정적 메소드(static)		클래스처럼 호출됨, method 영역
	인터페이스참조변수		stack영역, 실제객체는 heap영역

	
7) 인터페이스의 불편함
	인터페이스는 강제성이 강하기 때문에 구현하는 클래스에서 일부만 재정의하여 사용하는 것이 불가능 하다
	이를 해결하기 위해 Adapter 라는 추상 클래스를 활용한다

3. 어댑터 클래스(Adapter Class)
	인터페이스를 미리 구현한 추상 클래스
	모든 메소드를 비어잇는 메소드(기본 구현)로 만들어 둔 클래스 
	필요한 메소드만 오버라이딩해서 사용하면 되므로 개발자가 편하게 활요할 수 있다

1) 사용하는 경우
	인터페이스의 메소드가 많은 경우
	많은 메소드들 중에서 일부만 구현하고 싶은 경우

2) 어댑터 클래스(추상 클래스)와 인터페이스
	인터페이스의 강제성을 완화시키기 위해 Adapter 클래스를 사용한다
	어댑터 클래스는 추상 클래스로 만들기 때문에 미구현된 메소드와 구현된 메소드가 동시에 존재할 수 있다
	그러므로 어댑터 클래스에서 인터페이스를 상속받아 강제성을 없애고 싶은 메소드만 재정의 해준다
	이 후 어댑터 클래스를 상속받는 자식 클래스는 내가 원하는 메소드만 재정의 할 수 있게 된다
	이 때 어댑터 클래스의 이름은 클래스명뒤에 Adapter를 붙여서 목적을 알려준다
	
	인터페이스(모든 강제성)----(일부구현)------->추상클래스(일부강제성)----(상속)----> 클래스
		

4. 마커 인터페이스(Marker Interface)
	클래스들을 그룹화하기 위한 목적으로 사용한다
	서로 다른 클래스들을 공통되는 타입을 갖도록 하는 것이 유일한 목적이기 때문에 마커 인터페이스는
	어떠한 멤버도 선언하지 않는다



초식동물    육식동물      	잡식동물
얼룩말
사슴
말        호랑이
         독수리
         상어
         늑대
               		개	
               		참새
              	 	비둘기
              	 	원숭이
               		고양이

일반 클래스 => 필드(인스턴스변수, 스태틱변수, 상수), 메소드(인스턴스 메소드, 스태틱 메소드), 생성자 + 클래스
추상 클래스 => 필드(인스턴스변수, 스태틱변수, 상수), 메소드(인스턴스 메소드, 스태틱 메소드, 추상메소드)
인터페이스 => 상수, 추상메소드 + jdk8 default 메소드, static 메소드 + jdk9 private 메소드
어댑터 클래스=> 추상클래스와 동일

5. 내부클래스(Inner Class)
	클래스 내부에 선언된 클래스를 내부 클래스라고 한다
	내부클래스를 가진 클래스를 외부 클래스라고한다
	클래스를 구성하는 멤버로 필드, 메소드, 생성자 + 클래스도 가질 수 있다
	만약 B클래스를 A클래스 내부에서만 사용한다면 B클래스를 내부 클래스로 만들어서 사용한다
	외부 클래스가 메모리에 할당되어야 내부 클래스의 객체화가 가능하기 때문에 B만 별도로 사용하지 못한다
	내부 클래스는 외부 클래스의 멤버이기 때문에 외부 클래스의 멤버를 상속 없이 사용할 수 있다

1) 내부 클래스를 사용하는 이유
	내부클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다
	코드의 복잡성을 줄일 수 있다
	- 캡슐화: 내부클래스를 외부 클래스 내부에서만 사용가능하므로 외부 클래스의 내부 구현을 숨기고 캡슐화 할 수 있다
	- 코드 재사용: 내부 클래스를 사용하면 특정 외부 클래스에서만 사용하는 클래스를 정의하고 재사용할 수 있다
	- 코드 유지보수성 향상: 관련 있는 클래스를 논리적으로 그룹화하여 코드를 구조화 하고 유지보수를 용이하게 만든다
	+) 웹 개발보다는 앱개발에서 더 많이 사용된다(익명클래스를 이해하기 위함)

2) 내부 클래스의 종류
	선언위치에 따른 분류		선언위치			객체생성조건		파일이름
	인스턴스 내부 클래스		Class A{		A클래스의 객체를 생성해야	A%B.class	
				  class B{		B클래스의 객체를 생성가능함	A: 외부클래스 
				  }						B: 멤버클래스
				}			

	스태틱 내부 클래스		Class A{		A클래스의 객체를 생성하지않아도
				 static class B{	B클래스의 객체를 생성할 수 있음
				 }
				}

	로컬 내부 클래스		Class A{   		method가 호출되어 실행할때만	A$ B.class
				 void method(){		B객체를 생성할 수 있음	A: 외부클래스
				  Class B{					B: 로컬클래스
				  }
				 }		
	 			}


6. 익명 클래스(Anonymous Class)
	이름이 없는 클래스
	미구현된 멤버를 구현하여 일회성으로 객체를 생성하기 위해 사용한다
	익명클래스는 추상 클래스나 인터페이스를 구현할 때 유용하게 사용된다
	이를 통해 자식 클래스를 생성하여 부모 타입 변수에 저장할 필요없이 인터페이스나 추상 클래스를 구현하여 객체를 생성할 수 있다
	익명클래스는 클래스 내부에서 선언하며, 객체를 생성할 때 바로 구현해주는 방식으로 사용된다

