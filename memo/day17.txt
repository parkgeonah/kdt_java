day17(java 13일차)

* QR 체크 꼭 확인 할 것~!!!
* 9시 00분에 자리 없는 사람(현재 팀 과제 때의 각 팀 팀장이 파악할 것)

지각 : 버들, 태현, 승우, 기수, 건아

[A4용지 2장 배분]
1장
왼쪽 최상단에 이름 작성

1. 올해 자격증 목표
- 자격증 순서(번호로 작성) 이것 꼭 취득하겠다가 제일 첫번째로 작성할 것

2. 6월 목표 달성률
- 각 목표 100% 기준
  이유도 같이 작성

3. 7월 목표
- 개인목표(자격증)

- 수업목표

4. 하루 공부 시간
- 월~금    최소 가능 시간
   최대 가능 시간
- 주말
※ 알바나 개인 일정이 있다면 언제 알바인지, 학교수업인지 등 따로 기재



왼쪽 상단에 이름 오늘날짜(25.7.3)
개념문제
1. 제어문
   조건문(if문, switch문), 반복문(for문, for-each문, while문, do~while문), 기타제어문(break문, continue문)

2. 추상 메소드, 일반메소드, 인터페이스
일반메소드
   접근제한자 리턴타입 메소드명(자료형 매개변수){
      //실행할 문장
      //return 리턴값;
   }
추상메소드
   자식 클래스에서 반드시 해당 메소드를 구현해야하는 경우 사용한다(강제성)
   접근제한자 abstract 리턴타입 메소드명(자료형 매개변수);

인터페이스
   강제성 부여
   상수, 추상메소드 포함


3. 접근제한자
   public, protected, (default), private

4. 다형성
   오버로딩      메소드, 생성자
   오버라이딩    상속관계인 자식 클래스 메소드
   참조변수의 다형성(매개변수의 다형성)   상속관계 부모클래스 타입으로 매개변수에서 사용가능
               부모클래스타입의 참조변수에 자식클래스 참조값 대입가능

5. 메모리 영역 관점에서 각 변수의 차이
   인스턴스변수   참조변수는 stack   참조값(생성자)   heap
   스태틱변수      method
   매개변수      stack
   지역변수      stack
   상수      method
   인터페이스 익명클래스로 객체화?

코드작성문제(손코딩)
클래스는 대표 클래스로 작성
public class 클래스명{
      //필드
      //메소드
   출력 시 syso();으로 작성
      //생성자
      public 클래스명(){

      }
   오버라이딩 시 @Override
}

1. Person 클래스를 상속하는 Student 클래스를 작성하기
Person 클래스의 필수 멤버(필요한 것은 추가하여 작성)
   필드 : 이름, 나이(접근제한자 private)
   생성자 : 매개변수 모두 받는 생성자(접근제한자 public)
   점수계산메소드(접근제한자 public, 메소드명 score) => 점수가 없습니다 출력
   
Student클래스
   필드 : 점수(접근제한자 private)
   생성자 : 매개변수 모두 받는 생성자(접근제한자 public)
   점수계산메소드 오버라이딩 => 학생이름의 점수는 몇점입니다 출력

2. 위에서 만든 Person클래스 Student클래스의 상속구조를 추상클래스나 인터페이스 구조로 확장하기
   abstract      extends
   interface      implements

=======================================================================================================
익명클래스 -> 람다식 -> 예외처리 -> API -> Object 클래스 -> Warpper 클래스

1. 익명클래스
	이름이 없는 클래스
	미구현된 멤버를 구현하여 일회성으로 객체를 생성하기 위해 사용한다
	익명클래스는 추상 클래스나 인터페이스를 구현할 때 유용하게 사용된다
	이를 통해 자식 클래스를 생성하여 부모 타입 변수에 저장할 필요없이 인터페이스나 추상 클래스를 구현하여 객체를 생성할 수 있다
	익명클래스는 클래스 내부에서 선언하며, 객체를 생성할 때 바로 구현해주는 방식으로 사용된다

2. 람다식(lambda)
1) 식(Expression)과 문(Statement) 차이
	식: 조건식, 증감식, 초기식
		식은 결과가 값이다. 
		java에서 값을 계산하고 결과를 반환하는 구문이다	
		1+2, "Hello Wold"

	문: 조건문, 반복문, 기타제어문
		문은 값이 아니기 때문에 변수에 저장할 수 없고 매개변수로 넘겨 줄 수 없다
		문은 식을 포함할 수 있다
		java에서 실행가능한 최소한의 코드 블록
		하나 이상의 식을 포함할 수 있다
		if문, for문, switch문 ....

2) 함수형 인터페이스(Fumctional Interface)
	단 하나의 추상 메소드를 가지고 있는 인터페이스
	@FunctionalInterface 어노테이션을 명시해주면 하나의 추상 메소드만 선언할 수 있도록 제한 할 수 있다

3) 람다식 : 익명메소드
	jdk8 이상부터 사용가능하다
	메소드를 하나의 식으로 표현한다
	람다식을 매개변수로 전달 가능하며, 반환도 가능하다
	함수형 인터페이스는 추상 메소드가 한 개만 선언되기 때문에 람다식으로 재정의 할 때 메소드 이름이 필요 없다

4) 람다식 문법
	매개변수 -> 바디
	★★ lamdaTest 패키지에 LambdaTest.java 참고 ★★

+) 람다식 활용
	스트림API 많이 활용
	이벤트 팬들러
	쓰레드와 비동기 처리
	커스텀 함수 인터페이스
	
3. 예외처리 
1) 오류의 종류			
	에러(Error): 개발자가 해결할 수 없는 문제(코드로 수습 불가)

	예외(Exception): 개발자가 해결할 수 있는 문제(코드로 수습 가능)

2) 예외의 발생시점
	확인된 예외(Checked Exception, 일반예외)
		컴파일 단계에서 발생하는 예외(이클립스 빨간줄)

	미확인 예외(Uncecked Exceprion, 실행 예외 Runtime Exception)
	프로그램 실행 중(런타임) 발생하는 예외

	자바의 모든 예외클래스는 Throwable을 상속받은 클래스로 만들어지고
   	예외 클래스는 Exception 클래스를 상속받는다
  	실행 예외는 RuntimeException과 해당 클래스를 상속받는 자식클래스이고
   	그 밖의 예외는 모두 일반예외이다

3) 예외처리
	   예외가 발생했을때 프로그램이 비정상적으로 종료되는 것을 막고 정상적으로 실행될 수 있도록 처리하는 것을 의미한다

	try{
		예외가 예상되는 코드
	}catch(예외클래스명 참조변수명){
		예외를 처리하는 명령문(예외발생시 실행할코드)
	}catch(예외클래스명 참조변수명){
		예외를 처리하는 명령문(예외발생시 실행할코드)
	}..{
	}finally(
		예외발생 여부에 상관없이 무조건 실행할 코드(실행가능)
	}

	try블록에서 작성한 코드가 예외 없이 정상실행된다면 catch블록은실행되지 않고 finally문이 실행된다
	catch는 위에서부터 검사하므로 위에서 예외가 잡히면 다른 catch문은 건너뛰고 finally문이 실행된다

4) 예외클래스에서 제공하는 메소드	
	자바에서는 발생할 수 있는 예외들을 클래스로 정의해두었다
	만약 실행 중 오류가 발생하면 해당 오류클래스의 객체가 생성된다(메모리에 할당된다)
	예외처리를 해두었다면 그 객체의 주소를 catch(예외클래스 참조변수)의 참조변수가 받게 된다
	예외클래스에서는 다양한 기능을 제공한다
	
	.getMessage()  		예외 메시지를 문자열로 반환
	.toString()	 	발생한 예외객체를 문자열로 반환
				생략가능(참조변수를 출력하면 자동으로 toString()가 사용됨)
	.printStackTrace() 	예외가 발생지점을 추적하여 단게별로 전부 출력함

	=> 예외처리를 적절하게 수행하면 프로그램의 안정성을 높이고, 신뢰성 잇는 프로그램을 만들 수 있다

5) throws와 throw
	메소드 내부에서 예외가 발생할 때 try-catch블록으로 예외 처리하는 것이 기본이지만
	메소드를 호출하는 곳을 예외처리를 떠넘길 수 있다

- throws : 예외 던지기, 메소드의 선언부에 사용한다
	메소드에서 발생할 수 있는 오류를 메소드를 정의하는 부분에서 처리하지 않고
	해당 메소드를 호출하는 쪽으로 던져서 메소드를 사용하는 개발자가 처리하도록 한다(상황에 맞게 예외처리하기 위함)

	ex) 접근제한자 리턴타입 메소드명() throws 예외클래스명{}
	ex) 접근제한자 리턴타입 메소드명() throws 예외클래스명1, 예외클래스명2{}

- throw : 예외 강제 발생시키기
	ex) throw new 예외명();

6) 사용자 정의 예외 클래스
	사용자 정의 예외는 컴파일러가 체크하는 일반 예외로 선언할 수도 있고, 컴파일러가 체크하지 않는 실행예외로도 선언 할 수 있다
	
	일반 예외는 Exception 클래스를 상속받는 자식클래스로 선언하고
	실행 예외는 RuntimeException 클래스를 상속받는 자식 클래스로 선언한ㄷ

	기본생성자와 예외 메시지를 입력받는 생성자를 선언해주거나 super()에 예외 메시지를 전달한다

	   class 사용자정의예외클래스명 extends Exception or RuntimeException{
      		생성자(){
         	super("사용자 정의 예외 메시지");
     	 	}
   	  }