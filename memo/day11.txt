day11(java 9일차)

복습 -> 생성자 -> 오버로딩 -> this, this() -> static

0.복습
1) 메소드
	하나의 기능을 하는 코드블록

- 메소드 정의
	반환타입 메소드명(자료형 매개변수){
		실행할문장:
		return 리턴값;
	}

- 메소드 호출방법
	매개변수 x 반환타입 x => 객체명.메소드명();
	매개변수 o 반환타입 x => 객체명.메소드명(인수);
	매개변수 o 반환타입 x => syso(객체명.메소드명());
				자료형 변수명 = 객체명 객체명.메소드명();
	매개변수 o 반환타입 o => syso(객체명.메소드명(인수));
				자료형 변수명 = 객체명.메소드명(인수1,인수2);
	
2) 메소드 오버로딩
	하나의 메소드명으로 매개변수의 개수, 타입, 순서가 다를 때 정의할 수 있는 것을 의미
	객체지향언어 => 다형성의 특징 중 하나

3) 메소드와 메모리
	메소드 매개변수, 지역변수	Stack메모리
	
- 메소드를 사용하기 위해 2가지 방법
	메소드 정의할 때 선언부 static 키워드를 붙인다
	클래스의 객체를 만들어서 사용한다

		참조변수	참조값
	클래스타입 객체명 =	new 클래스명();
	-----------	--------------
	Stack			Heap

4) 클래스
	사용자 정의 타입으로 필드와 메소드를 묶어서 관리할 수 있는 설계도

- 클래스의 특징
	사용자 정의 타입이다
	연관성 있는 저장공간과 기능을 한 곳에 모아 관리할 수 있다
	객체를 생성하기 위한 틀

- 클래스 선언
	class 클래스명 {
		// 필드;
		// 메소드;
	}

- 객체화(인스턴스화)
	클래스명 객체명 = new 클래스명();
	클래스타입 참조변수 = new 생성자();

- 클래스 맴버에 접근
	객체명.필드명 =  "값";
	syso(객체명.필드명);

	객체명.메소드명();
	객체명.메소드명(인수);
	syso(객체명.메소드명());
	syso(객체명.메소드명(인수));

============================================================================

1. 생성자(Consturctor)
	클래스 이름 뒤에 소괄호가 있는 형태, 메소드와 비슷하지만 메소드라고 부르지 않는다
	생성자는 리턴이라는 기능이 존재하지 않는다
	객체가 생성될 때 자동으로 실행되며, 주로 클래스의 필드를 초기화하는데 사용된다

	- 생성자는 클래스이름과 동일한 이름을 가지며, 반환값이 없는 특별한 메소드이다
	
1) 생성자의 특징
	클래스 이름과 동일한 이름을 사용한다
	반환타입을 명시하지 않는다(void도 사용하지 않음)
	객체를 생성 시에 new 키워드를 통해 호출되며 직접 호출할 수 없다
	생성자를 정의하지 않으면 기본생성자(매개변수가 없는 생성자)가 자동으로 추가가 된다
	- 하지만 개발자가 생성자를 하나라도 정의하면 기본 생성자는 자동으로 만들어지지 않는다

2) 기본생성자
	public 클래스명(){}
	매개변수가 없다
	클래스 선언시 자동으로 선언되며 사용자가 직접 생성자를 선언하게 되면 자동으로 만들어주지 않는다

3) this
	객체 자기자신, this는 자동으로 생성되는 변수이다
	현재 객체 자싱을 참조하는 특별한 키워드
	클래스 내부에서 필드와 메소드를 가리킬 때 사용된다

- this 키워드를 사용하는 이유
	맴버변수(필드)와 지역변수나 매개변수의 이름이 동일할 때 구분
	가독성 향상
	다른 생성자 호출 및 메소드 체이닝 구현

4) 생성자 오버로딩
	하나의 클래스에 여러개의 생성자를 정의할 수 있다
	각 생성자는 매개변수의 개수, 타입, 순서가 달라야한다

5) this()
	자기자신의 생성자
	생성자 내부에서만 사용가능하며 최상단(첫번째 줄)에 작성해야한다
	-> 생성자 내부에서 나의 다른 생성자를 호출할 때 사용한다



2. static
	정적인
	프로그램이 시작하면 생성되고 프로그램이 종료될 때 까지 유지된다
	프로그램이 실행되는 동안 계속해서 유지되는 저장공간

1) 정적맴버(Static Member)
	정적맴버는 클래스 자체에 속하는 맴버, 클래스를 통해 접근
	객체를 생성하지 않아도 사용할 수 있다
	정적변수와 정적메소드가 포함된다

- 정적변수 : 클래스의 모든 인스턴스(객체)에서 동일한 값을 공유, 객체간의 정보 공유에 사용된다

- 정적메소드 : 객체를 생성하지 않아도 호출 가능하고 주로 유틸리티 메소드나 공통 동작을 구현하는데 사용한다

2) 맴버변수와 멤버 메소드의 종류
	static이 붙은 변수 : static 변수, 클래스변수, 정적변수
	static이 붙지 않은 변수 : 인스턴스 변수

	static이 붙은 메소드: static 메소드, 클래스 메소드, 정적 메소드
	static이 붙지 않은 메소드: 인스턴스 메소드

3) static 변수와 static 메소드
	static 변수, static 메소드는 객체를 생성하지 않아도 클래스 이름을 통해 직접 사용할 수 있다
	객체의 생성과는 무관하게 클래스 로딩시에 메모리에 올라가며 프로그램이 실행되는 동안 유지된다

	static 변수는 객체와 상관없이 하나의 저장공간이므로 모든 객체가 공유해서 사용한다
	즉, 모든 객체에 공통으로 사용되는 변수에 static을 붙이는 것을 고려한다

	static 메소드는 인스턴스 멤버를 직접 사용할 수 없다
	static 메소드가 메모리에서 사용준비가 끝나도 인스턴스 멤버는 new를 사용하여 객체를 생성하기 전까지 
	사용할 수 없기 때문이다

+) 정적변수는 클래스 수준에서 선언되며 클래스의 모든 객체간에 공유되는 변수이다
	한 번 메모리에 할당되면 프로그램이 실행중일 때 항상 존재하며 수정이 가능하다
	클래스가 처음 사용되거나 정적멤버에 접근하면 해당 클래스가 메모리에 로드되고
	클래스의 정적변수 및 정적메소드가 method 영역에 할당되는데 이 과정을 클래스 로딩이라고한다
	정적변수의 변경은 해당 클래스의 모든 객체에 영향을 끼친다
	method 영역은 가비지컬렉션의 영향을 받지 않는다
	객체가 해제되더라도 method 영역에 할당된 데이터는 프로그램의 종료까지 유지된다

+) 메모리 구조
Method영역
	- 모든 클래스와 static 멤버가 저장되는 영역
	- 클래스 로더가 클래스를 로드할 때 해당 클래스의 메타 데이터와 함께
	  static 변수와 static 메소드가 여기에 저장된다
	- 프로그램 실행동안 유지되며 모든 객체 공유한다

Heap 영역
	- new 키워드로 생성된 객체와 그 객체의 인스턴스 변수(필드)가 저장된다
	- 객체마다 별도의 저장공간을 가진다
	- Garbage Collector(가비지 컬랙터)가 관리한다

Stack 영역
	- 메소드의 지역변수, 매개변수와 메소드 실행정보가 저장되는 영역
	- 메소드가 호출 될 때 스택 프레임이 생성되고 종료되면 프레임이 제거된다

PC Register(프로그램 카운터 레지스터)
	- 각 쓰레드가 실행중인 명령어의 주소를 저장

Navite Method Stack(네이티브 메소드 스택)
	- Java가 아닌 네이티브 코드(C, C++등)로 작성된 메소드를 호출 시 사용


--------------------------------------------------------------------

생성자
	객체 생성시에 반드시 호출된다
	객체를 만들 때 초기값을 넣을 때 사용한다
	클래스명 객체명 = new 생성자();

- 생성자 오버로딩
	객체를 만들 때 생성자의 매개변수의 타입, 순서, 개수가 다르면 여러개를 선언할 수 있다

- this, this()
	this: 객체 자기자신, 참조값
	this(); 생성자 자기자신, 생성자안에서만 호출, 최상단에 작성한다

- static
	변수, 메소드
	클래스명.스태틱변수명;
	클래스명.메소드명();
	스태틱 변수에 담긴 값은 모든 객체가 공통된 값을 사용한다

- 메모리
	Heap : 동적메모리
		new 키워드로 생성된 객체와 인스턴스 변수

	Stack : 메소드의 지역변수, 매개변수, 메소드 실행정보 저장
	
	Method : static 키워드가 붙은 변수와 메소드
		프로그램 시작부터 끝까지 유지된다
