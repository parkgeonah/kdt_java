day15(java 13일차)

[시험]
문제 1. 괄호에 들어갈 알맞은 답을 작성하세요.(20점)
(1) 메소드 선언 시 괄호 안에 선언되며 호출 시 전달되는 값을 저장하는 변수는 ( )이다.   매개변수
(2) 클래스 중괄호 안에서 선언되며 객체가 생성될 때마다 생성되는 변수는 ( )이다.      인스턴스 변수
(3) boolean, char, int 등은 모두 ( ) 자료형이다.            기본
(4) 하나의 자료형으로 여러 값을 저장할 수 있는 공간의 집합은 ( )이다.      배열
(5) static 메소드 호출 방법 4가지를 모두 작성하세요.
   매개변수 리턴값   호출방법
   x   x   클래스명.메소드명();
   o   x   클래스명.메소드명(인수);
   x   o   syso(클래스명.메소드명()); or 자료형 변수명 = 클래스명.메소드명();
   o   o   syso(클래스명.메소드명(인수)); or 자료형 변수명 = 클래스명.메소드명(인수);


문제 2. 다음 문장을 읽고 O/X로 답하고, X인 경우 간단히 수정하거나 설명하세요.(10점)
(1) static 메소드는 객체 생성 없이 클래스명으로 호출할 수 있다. ( O )
(2) 생성자가 하나도 없으면 컴파일러는 기본 생성자를 자동으로 생성하지 않는다. ( X )
      => 생성자가 없으면 컴파일러가 기본 생성자를 자동으로 생성한다
(3) 상속받은 메소드를 자식 클래스에서 같은 이름으로 재정의하는 것을 오버로딩이라 한다. ( X )
      => 오버라이딩
(4) 객체지향언어의 특징에는 다형성, 클래스, 상속, 캡슐화가 포함된다. ( O )
(5) this()는 클래스 내 다른 메소드를 호출하는 키워드이다. ( X )
      => this() 클래스 내 다른 생성자 호출하는 키워드이다

 

문제 3. 정수 배열에서 최대값과 최소값을 출력하는 메소드를 작성하려고한다. (20점)

코드 작성없이 한글로 로직구성만 하되, 메소드 정의 방법에 따라 순서 맞춰 작성하세요.

 

문제 4. 구구단을 2단부터 9단까지 출력하세요. (20점)

- for문 이용 (ForGugudan) 로직구성 필요없음
 
- while문 이용(WhileGugudan) 로직구성 필요없음
 
[출력결과]

 

문제 5. 아래 요구사항에 따라 학생 정보를 관리하는 자바 프로그램을 작성하시오.(30점)
[요구사항]
(1) Major 열거형(enum) 정의
전공을 나타내는 열거형 Major를 별도 파일(Major.java)로 생성한다.
다음 전공 상수를 포함한다.

상수명    한글 전공명
COMPUTER_SCIENCE   컴퓨터공학
CYBER_SECURITY   정보보안학
ARTIFICIAL_INTELLIGENCE   인공지능학

각 상수는 한글 전공명을 저장하는 final private koreanName 필드를 갖는다.
생성자를 통해 초기화하며, 한글명을 반환하는 getKoreanName() 메소드를 작성할 것

(2) Person 클래스 정의
필드
    String name
생성자
    이름을 매개변수로 받아 초기화
메소드
    getName() — 이름 반환

(3) Student 클래스 정의
Person 클래스를 상속받는다.
필드
    int javaScore
    int dbmsScore
    int htmlScore
    Major major
생성자
    이름, 전공, 세 과목 점수를 받아 초기화(부모생성자 사용)
메소드
    getTotalScore() – 총점 반환
    getAverageScore() – 정수 평균 반환
    getMajor() – 전공 반환

(4) Main 클래스 작성
사용자로부터 학생 수를 입력받는다.
각 학생에 대해 다음 정보를 입력받는다.
    이름, 전공 (COMPUTER_SCIENCE / CYBER_SECURITY / ARTIFICIAL_INTELLIGENCE), Java, DBMS, HTML 점수

3명의 학생 점수를 입력받고 결과가 아래와 동일하게 나올 수 있도록 한다.

[입출력결과]


---------------------------------------------------------------------------------------------------------
복습 -> 접근제한자 -> 캐스팅 -> 추상 클래스

0. 복습
1) 상속 
	클래스의 확장
	class 자식클래스명 extends 부모클래스명{
		// 부모멤버, 자식멤버
	}
	단일상속만 있다

2) 생성자
	super() 	부모의 생성자
	기본생성자
		매개변수가 없는 생성자
		매개변수가 없더라도 초기화는 {}영역안에서 가능함
		super() 모든 클래스의 최상위 부모클래스 Object 클래스의 기본 생성자
		상속 관계에서는 super() 해당 부모클래스의 생성자

	매개변수가 있는 생성자
		매개변수를 통해 객체 생성시 원하는 값으로 초기화하기 위해 사용하는 생성자
		다양한 초기화 옵션을 제공하기 위해 오버로딩 가능함
		
3) 다형성
	하나의 것이 여러가지 형태를 가질 수 있는 성질
	오버로딩(메소드, 생성자) : 매개변수의 개수, 순서, 타입이 다르면 같은 이름으로 선언가능함
	오버라이딩(메소드): 상속관계에서 자식클래스에서 부모클래스에 있는 메소드를 재정의함
	참조변수의 다형성(매개변수의 다형성) - 캐스팅

4) this, this(), super, super()
	this: 객체 자기자신(참조값)
	this(): 자기자신의 생성자
	super: 부모의 참조값
	super(): 부모의 생성자

5) 접근 제한자
	접근제한자		|제한대상			|제한범위
	public		|클래스, 필드, 생성자, 메소드 	|없음
			|			|
	protected	|필드, 생성자, 메소드		|같은 패키지거나 상속관계에서 자식객체만 사용가능
			|			|
	(default)	|클래스, 필드, 생성자, 메소드	|같은패키지
			|			|
	private		|필드, 생성자, 메소드		|같은클래스


1. 접근제한자(private) 
1) setter, getter(단축키 : alt + shift + s + r)
	setter, getter 사용해야한다
	setter, getter 접근 제한자는 public이다
	setter 메소드는 매개변수로 값을 저장만 해줄것이기 때문에 리턴타입은 void
	메소드명 setter에서 set을 따오고 + 필드이름(첫글자는 대문자), 카멜 표기법
	매개변수 타입은 필드 타입

	getter 메소드는 값을 외부로 리턴해줘야하기 때문에 리턴타입은 필드의 타입으로 설정
	메소드명 getter에서 get을 따오고 + 필드이름(첫글자는 대문자), 카멜 표기법
	리턴값은 필드값
	
+) 객체의 필드(데이터)를 외부에서 마음대로 읽고 변경할 경우 객체의 무결성이 깨질 수 있다
	학생의 점수는 음수가 될 수 없는데 외부에서 음수로 변경하면 객체의 무결성이 깨진다
	객체지향 프로그래밍에서는 직접적인 외부에서의 필드 접근을 막고 대신 메소드를 통해 필드에 접근하는 것을 권장한다.
	메소드는 데이터를 검증해서 유효한 값만 필드에 저장할 수 있기 때문이다	
	이 역할을 하는 것이 setter 메소드이다
	외부에서 객체의 필드를 읽을 때도 메소드가 필요한 경우가 있다
	필드값이 객체 외부에서 사용하기 부적절한 경우 메소드로 적절한 값으로 변환하여 리턴할 수 있기 때문이다
	이런 역할을 하는 것이 getter 메소드이다
	=> 캡슐화, 은닉화	

2. final 클래스와 final 메소드
	final 최종을 의미하는 키워드
	final 클래스 : 최종적인 클래스이므로 더이상 상속할 수 없는 클래스
			부모클래스가 될 수 없으므로 자식클래스를 만들 수 없다
		대표적인 클래스 : String 클래스

	final 메소드 : 최종적인 메소드이므로 오버라이딩을 할 수 없는 메소드가 된다
		부모클래스의 메소드에서 final을 사용하면 자식 클래스에서 재정의 할 수 없다

3. Casting ★★★★★(매우 중요)
1) Up Casting
	자식값을 부모 타입으로 형변환(자동 타입 변환)
	부모타입 잠조변수 = 자식타입 객체;
	
	부모클래스 타입의 참조변수로 자식 클래스의 객체를 가리킬 수가 있다
	업 캐스팅 후에는 부모 클래스의 맴버(필드와 메소드)에만 접근할 수 잇따
	자식 클래스의 멤버는 참조할 수 없지만 객체 내부에는 여전히 자식 클래스의 멤버가 존재한다
	명시적 캐스팅이 생략 가능

	부모클래스타입 참조변수 = (부모클래스타입) new 자식클래스생성자();
	부모클래스타입 참조변수 = (부모클래스타입) 자식객체;
	부모클래스타입 참조변수 = new 자식클래스생성자();

2) Down Casting
	이미 UP Casting 된 객체를 자식 타입으로 형 변환
	※ 부모 값을 자식 타입으로 형 변환시 오류 발생!!!
	※ 자식 클래스 타입의 객체는 부모 클래스 타입도 동시에 갖는다!!!!

	업 캐스팅 된 객체를 다시 자식 클래스 타입으로 변환하는 것을 의미하며
	명시적 캐스팅이 필요하다
	다운 캐스팅 후에는 자식 클래스의 멤버(필드와 메소드)에 접근할 수 있다
	잘못된 다운캐스팅(자식타입의 객체에 부모타입의 주소값을 저장, 부모객체를 자식타입으로 변환시도)는
	ClassCastException 예외가 발생한다	

3) Casting을 사용하는 이유
	부모타입인 하나의 저장공간에 여러 자식 타입의 참조값을 업 캐스팅하여 저장할 수 있다(참조변수의 다형성)
	만약 하나의 기능을 하는 메소드를 만들 때 매개변수로 여러 자식타입을 각각 받아야한다고 가정해보자
	Casting이 없었다면 자식 타입을 매개변수로 받는 메소드를 타입별로 각각 만들어야한다
	(자식끼리는 타입이 다르기 때문이다)
	Casting을 활용하면 부모 타입의 매개변수를 가진 하나의 메소드만 만들면된다
	(부모타입의 참조변수로 모든 자식 타입을 저장할 수 있기 때문이다)

※ 주의사항
	- 업 캐스팅된 자식의 참조값을 저장했다면 자식 클래스에 오버라이딩 된 기능이 실행된다
	- 업 캐스팅된 자식의 참조값을 저장했다면 자식 클래스에서 구현한 기능들은 사용할 수 없다
	이 경우 Down Casting을 통해서 복구하고 사용한다

4) 다형성
	하나의 것이 여러가지 형태를 가질 수 있는 성질
	- 오버로딩: 생성자, 메소드
		같은 이름으로 매개변수의 타입, 순서, 개수가 다르면 선언할 수 있다
		반환타입은 영향을 끼치지 않는다

	- 오버라이딩: 상속받은 자식 클래스의 메소드
		부모클래스에 정의된 메소드 선언부를 그대로 쓰고 구현부만 재정의한다
		선언부는 무조건 똑같아야한다

	- 참조변수의 다형성(매개변수의 다형성): 메소드 매개변수(상속 관계에서 부모클래스 타입)
		부모 클래스타입의 참조변수로 자식 클래스 객체를 가리키는 것을 허용하는 것을 의미한다

5) 객체 간 타입 비교
	객체명 instanceof 클래스타입
	a instenceof A: 조건식, 참 / 거짓 중 하나가 나오는 식
		a가 A클래스 타입이면 true
		a가 A클래스 타입이 아니면 false

과제
부모클래스 : Person
자식클래스 : Student, Teacher, Employee

공통 메소드: introduce() 자식클래스에서는 오버라이딩
모든 필드는 private
생성자는 이름을 갖고 있는 생성자

Preson 클래스
필드: 이름, 나이, 생년월일(8자리)
메소드: introduce() 이름, 나이입니다 출력

Student 클래스
필드: boolean stu
생성자: 매개변수 stu도 포함
메소드: study()	
메소드 오버라이딩: 이름은 학생입니다 출력

Teacher클래스	
필드 x
메소드 teach()
	이름이가르칩니다 출력
메소드 오버라이딩 : 저는 선생님입니다 출력

Employee 클래스
필드: x
메소드 : work()
	업무를처리중입니다 출력
메소드 오버라이딩 : 저의 이름은 이고 회사원 입니다 출력

Main 클래스
static 메소드 (printInfo())
	객체 타입에 따라서 다운 캐스팅하여 전용 메소드 실행