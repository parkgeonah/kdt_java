1 변수와 자료형
- 변수: 메모리에 값을 저장해 두기 위해 할당받아 사용하는 특정 공간
- 변수의 선언 : 변수를 사용하기 전에 먼저 변수를 선언하고 초기화 해야하는데, 변수를 선언하기 위해서는 변수에 담을 데이터의 형태(자료형)와 변수 이름이 필요
- 자료형: 자료형에는 자바에서 기본으로 제공하는 기본자료형, 기본형을 제외한 모든 자료형인 참조 자료형이 있다

- 기본 자료형 종류
정수형: byte, short, int, long, 
실수형: double, float
문자형: char
논리형: boolean

- 형변환 자료형을 다른 자료형으로 변환하는 것 자동형변환과 강제형변환이 있다
강제형변환: 강제로 자료형을 변환 하는것 크기가 큰 자료형에서 크기가 작은 자료형으로 대입할 경우 변환할 수 있다
자동형변환: 자동으로 자료형이 변환되는 것을 말하며 크기가 작은 자료형에서 크기가 큰 자료형으로 대입할 경우 자동 변환

2. 연산자
- 연산자: 수학적 의미로 연산에 사용되는 기호, 피연산자란 연산 되는 값 즉 자바에서는 연산되는 데이터를 뜻한다
- 연산자 우선순위: 
최우선 연산자: (), ., []
단항 연산자: 증감(++, --), 부호(+,-), 비트(~), 논리(!)
산술 연산자: +, -, *, /, %,
쉬프트 연산자: >>, <<, >>>
관계 연산자: >, < , >=, <= , ==, !=
논리 연산자: 비트논리(&, ^, |), 논리(&&, ||)
삼항 연산자: 조건식 ? true일 때 실행: false일 때 실행;
대입 연산자 =

3. 제어문
- 조건문 : 조건식에 따라서 프로그램의 흐름을 제어할 수 있는 문법
- 조건문의 종류: 조건문은 크게 if문 switch문
1) if문 문법:
if(조건식){
	// 코드;
	}else{
	 //코드;
	}

2) if-else if 문법
if(조건식){
	// 조건식이 true일 때 실행할 코드;
}else if(조건식){
	// 조건식1이 false고 조건식 2가 true일 때 실행할 코드;
}else{
	// 위 조건식이 모두 false일 때 실행할 코드
}

3) switch 문법
switch(변수){
	case 값1: 
		 변수가 값1과 같을 때 실행할  코드
		break;
	case 값2:
		 변수가 값2와 같을 때 실행할 코드
		break;
	default :
		위 값들이 모두 만족하지 않을 때 실행할 코드
		break;
}

- 반복문: 동일한 내용의 일을 임의의 횟수만큼 반복하여 실행하는 문법
- 반복문의 종류: for문, 다중 for문, while문, do while문
1) for문 문법 : for문 순서 초기식 > 조건식 > 실행문 > 증감식 > 조건식 > 실행문
for( 초기식; 조건식; 증감식{
	실행할 코드;
}

2) while문 문법 : 주어진 조건을 만족할 때 까지 반복, 반복횟수 보다 조건에 의해 실행
while(조건식){
	실행문;
}


3) do while문 문법: while문과 같이 조건을 만족할 때 까지 반복, 처음 실행할 때는 조건과 상관없이 무조건 실행 이후 조건을 확인하고 만족하면 실행
do{
	실행문;
}while(조건식);

4) for-each문 문법 : 순서 반복대상 > 변수 > 실행 코드 > 반복 대상> 변수
for(자료형 변수명 : 반복대상){
	실행할 코드;
}


- 기타 제어문
continue: 뒤에 있는 실행코드는 수행되지 않고 현재 반복을 종료하고 반복문의 처음으로 되돌아 간다
break: 내부의 반복 실행 종료

4. 배열
- 배열: 같은 타입의 데이터를 여러개 저장할 수 있는 자료구조
배열의 선언
1) int[] arr = new int[크기];
2) int[] arr  = {값1, 값2, 값3};

- index: 생성된 배열의 위치 값을 말한다 index는 0부터 시작
- 배열의 길이:  배열이 가지고 length 값으로 배열의 길이를 알 수 있다
- Array: 배열을 지원하는 클래스로 배열과 관련된 다양한 기능을 가지고 있다
- 다차원 배열: 배열은 다차원으로 만들 수 있다, 다차원 배열 중 행렬 구조로 사용되는 2차원 배열이 주로 사용
다차원 배열읠 선언
1) int[][] arr = new int [행][열];
2) int[][] arr = {{값1, 값2. 값3}, {갑4, 값5, 값6}};

5. 클래스
- 객체지향 프로그래밍: 객체는 일반적으로 상태를 표현할 수 있으며 행동으로 실행할 수 있는 모든 것 객체를 중심으로 프로그램 구조를 설계하고 프로그래밍 하는 것을 객체 지향 프로그래밍이라고 한다
- 클래스: 클래스는 객체를 생성하기 위한 설계도면
클래스의 선언 
접근제한자 class 클래스명{

}

- 클래스를 구성하는 3가지 요소
1) 필드: 객체가 가져야할 데이터, 상태를 저장하는 변수
2) 메소드: 객체의 특정 기능을 수행하는 코드 블록
3) 생성자 객체를 생성하면서 객체 변수를 초기화 하는 역할(기능)을 하는 메소드

- 인스턴스멤버 / 정적멤버: 각 객체가 가지게 되는 필드와 메소드를 인스턴스 멤버라고  말하며, 모든 객체들이 공유하는 하나의 필드와 메서드를 정적 멤버라고 부른다
- static: 정적 멤버는 static 키워드로 선언할 수 있다 객체를 생성할 때 메모리에 올라가는 것이 아니라, 프로그램이 시작할 때 메모리에 올라가고 프로그램이 종료될 때 메모리에서 사라진다

6. 메소드
- 메소드: 클래스 안에서 특정 기능을 수행하기 위해 코드들을 하나의 블록으로 따로 묶어놓은 집합, 메소드를 구현함으로써 특정 기능잉 여러번 필 요할 때 코드를 반복적으로 사용하는 것을 피할 수 있다
- 메소드 기본구조: 메서드는 매개변수를 받아서 블록 안에서 사용할 수 있다
접근 제한자 반환타입 메소드명(자료형 매개변수){
	기능을 수행할 코드;
}

- 메소드 호출 : 메소드는 또 다른 메소드에서 호출되어 사용(같은 클래스에 있는 메소드 호출할 때는 메소드 이름만 호출)
- 리턴값: 메소드를 호출할 때, 매개변수를 전달해준 것처럼 필요에 따라서 메소드로부터 실행한 결과 값을 되돌려 받을 수 있따 메소드가 반환할 값이 잇다면 return구문을 통해 결과값을 반환하고
메소드를 종료해야 한다 return이 없다면 컴파일 에러 발생
- setter / getter: private 필드의 값을 대입하는 방법으로 setter 메소드 사용, 반대로 외부에서 private 필드의 값을 구하기 위해 getter메소드 사용


7. 생성자
- 생성자: 클래스를 구성하는 요소 중 하나인 생성자는 객체를 생성할 때 호출되어 객체의 초기화를 담당하는 특별한 메소드
- 생성자의 기본구조: 생성자는 일반 메소드와 달리 반환타입이 없으며, 이름은 클래스 이름과 동일
클래스명(매개변수1, 매개변수2){

}

- 생성자 호출: 생성자를 호출 할 때 new키워드를 사용해 호출
클래스명 객체명 = new 클래스명();

- 생성자 오버로딩: 매개변수의 개수와 자료형의 형태를 달리하여 생성자를 여러개 선언할 수 있다(이를 생성자 오버로딩이라 한다)

- this: this키워드로 객체가 자기자신 스스로를 참조할 수 있다 필드와 생성자 매개변수의 이름이 동일해도 구분하여 사용할 수 있다

- this(): 같은 클래스 안에 있는 생성자 중 매개변수 개수, 자료형, 순서에 맞는 다른 생성자를 호출하는 메서드로 생성자 내부에서만 사용할 수 있다 반드시 최상단에 위치해야 한다

8. 상속
- 상속: 부모클래스가 자식 클래스에게 클래스 멤버를 물려주는것을 상속이라고 한다
- 자식 클래스 선언: extends 키워드를 사용해 상속받을 클래스를 지명할 수 있다 자식 클래스는 부모 클래스의 멤버를 그대로 가져다 쓸 수 있다
클래스명 extends 부모클래스명{

}

- super(): 자식 클래스에서 부모 클래스의 생성자를 호출하는 키워드로 super()사용 필요에 따라 매개변수를 전달 할 수 있다 개발자가 직접 생성자를 선언할 때는 자식클래스에서 부모클래스의 생성자를 호출해야한다

- 접근제한자: java는 4가지 접근제한자 사용: public , protected, default, private
1) public: 모든패키지, 모든 클래스에서 접근가능
2) protected: 같은 패키지 안에서 접근가능, 상속관계라면 다른 패키지에서 접근 가능
3) default: 같은패키지 내에서만 접근 가능
4) private: 같은 클래스 내에서만 접근 가능

- 오버라이딩: 자식클래스가 상속 받은 메서드의 내용을 변경해서 사용할 수 있다 상속받은 메서드를 변경해서 다시 구현하는 것을 오버라이딩이라고한다
- 부모클래스의 메서드 호출: super키워드를 사용해 부모 클래스의 메서드를 호출할 수 있다
super.부모메서드();

9. 다형성과 타입변환
- 타입변환: 자바에서는 두가지의 대표적인 타입 변환이 있다
1) 자료형 타입변환
2) 클래스의 객체 타입변환: 상속관계의 클래스들만 가능

- 클래스의 자동 타입변환: 개발자가 직접 명시해주지 않아도 자동으로 타입변환이 일어나는 것을 자동 타입 변환이라고 부른다
상속관계에 잇는 자식클래스의 객체를 부모 타입의 객체로 변환(업캐스팅!)

- 클래스 강제 타입 변환: 자식 객체가 부모타입의 자동으로 타입 변환을 한 후, 다시 자식타입으로 변환하는 것을 강제 타입 변환이라고 부른다 개발자가 직접 명시해야만 타입변환이 가능(다운캐스팅!)

- 다형성: 객체지향프로그래밍의 대표적인 특징 중 하나로, 하나의 타입으로 다양한 객체를 사용할 수 있는것
1) 오버로딩 : 매개변수의 자료형, 개수, 순서를 다르게하여 재정의 하는 것
2) 오버라이딩: 부모클래스에게 상속받은 메소드를 자식클래스에서 재정의 자식 객체를 통해 메서드를 호출할 땐 오버라이딩된 객체가 호출
3) 참조변수의 다형성: 하나의 변수 이름으로 여러가지 클래스를 타입변환 할 수 있다

10. 추상클래스와 인터페이스
- 추상메소드: 구현 내용없이 구현부가 비어 잇는 메소드를 추상 메소드라고 한다 abstract 키워드 사용
접근제한자 abstract 반환타입 메소드명(매개변수1);

- 추상클래스: 추상매소드가 1개 이상이 있으면 클래스는 추상 클래스로 선언 되어야 한다
1) 일반클래스 처럼 독립적으로 생성자를 호출해 객체를 생성할 수 없다
2) 자식클래스의 생성자에서 super()를 통해 추상클래스의 생성자를 호출하여 부모 객체를 생성한 후 자식객체를 생성해야 한다

- 인터페이스: 인터페이스의 모든 메서드는 추상메소드이다 , 멤버로는 상수, 추상메소드만 가능
- 인터페이스 선언 : interface키워드를 사용해 선언 한다 어떤 형태로도 객체를 만들 수 없고 클래스라고 부를 수 없다 따라서 별도의 필드와 생성자도 존재하지 않으며 필드대신 상수를 선언하고 사용해야 한다
- 구현클래스: 인터페이스를 구현해주는 클래스를 구현 클래스라고 한다 implements 키워들를 사용해 구현한다
접근 제한자 class 클래스명 implements 인터페이스명

11. 내부 클래스
- 내부클래스: 두 클래스간에 서로 쉽게 접근하여 사용할 수 있도록 만드는 것을 말하며 중첩클래스라고도 한다 보통 바깥쪽의 클래스를 외부클래스, 안쪽 클래스를 내부클래스라고 한다
- 내부 클래스 구분
1) 인스턴스 클래스: 외부클래스의 멤버 변수와 같은 위치에 선언, 주로 외부클래스의 멤버 변수와 관련된 작업에 사용할 목적으로 선언
2) 정적 클래스: 외부 클래스의 클래스 변수와 같이 static 키워드 부여
3) 지역클래스: 외부클래스의 메소드 내부에서 선언하여 사용 메소드 영역에서 선언 되기 때문 에 메소드 내부에서만 사용 가능
내부클래스에서도 접근제한자를 두어 클래스의 접근에 대한 기능을 제한 할 수 있다

- 익명클래스: 다른 내부 클래스와는 달리 이름이 없는 클래스를 의미한다, 익명 클래스는 클래스의 선언과 객체의 생성을 동시에 하므로 한번만 사용할 수 있고 오직하나의 객체만은 생성할 수 있는
1회성 클래스 따라서 익명클래스는 보통 인터페이스를 상속하지 않고 일회성으로 기능을 구현하여 사용할 때 주로 사용

12. 예외 처리
- 예외처리 프로그램 구동 중에 예외가 발생했을 경우 프로그램의 갑작스런 종료를 막고 정상 동작할 수 있도록 처리하는 과정
- Error / Runtime Error : 프로그램에서의 오류로는 Error와 Runtime Error이 잇다 Error은 수습할 수 없는 치명적인 오류를 의미하며, Runtime Error은 에측할 수 있고 처리 가능한 오류를 의미한다
- try-catch : 예외처리는 try-catch구믄을 사요한다 try 영역에는 예외가 발생할 수 있는 코드를 입력하고 catch영역에는 발생되는 예외클래스를 매개변수로 선언하여 예외 발생 시 처리할 코드를 입력한다
catch구문을 여러개 사용하여 처리할 수 있다 catch문이 여러개 있더라도 차례대로 하나씩 실행되며 동시에 발생하지 않는다
- finally: finally키워드는 예외 발생 유무와 상관 없이 실행된다
- throws: throws키워드를 사용하면 메소드에서 발생하는 예외를 직접 처리하지 않고 호출한 곳에서 처리하도록 할 수 있다 메소드 뒤에 throws예외클래스를 붙여서 사용한다
- throw: 문법적인 예외가 발생하지 않더라도, 프로그램 규칙에 맞지 않거나 흐름에 문제가 생기면 사용자가 직접 예외를 발생 시킬 수 있다

13. 기본 API 클래스
- 자바API문서: 프로그램 개발에 자주 사용되는 클래스 및 인터페이스의 모음을 말하며 라이브러리라고 한다
httep/docs.oracle.com/en/java/javase/버전/intex.html 경로를 통해 문서를 확인할 수 있다

- Object클래스: 자바에서 사용되는 모든 클래스에 자동으로 상속되는 최상위 클래스
- equals()메소드: 객체를 동등 비교할 경우 객체의 값을 비교하는 것이 아니라 객체가 메모리에 있는 위치를 비교하게 된다, 
참조형 데이터 비교연산에는 적절하지 않으므로,객체의 데이터를 비교할 때은 메소드를 오버라이딩하여 사용한다
- hashCode(): 객체를 식별하는 하나의 정수값을 hashCode라고 한다 hashCode는 그것을 반환하는 메소드 이다
- toString(): 메소드 객체의 문자정보를 반환해주는 클래스 해당 메소드를 오버라이딩하여 사용하면 원하는 객체의 정보를 쉽게 출력할 수 있다
- String클래스: 문자열을 처리하는 객체형 데이터 타입으로 문자열을 처리하기 위한 다양한 기능들을 가지고 있다
String 객체를 비교할 때 ==을 사용하지않고  equals()를 사용한다
- Wrapper클래스: 기본 데이터 타입(int, float, long 등)의 값을 갖는 객체로 외부에서 변경할 수 없다 Wrapper클래스는 AutoBoxing 기능이 잇어서 객체화 하지 않고 일반 데이터 타입과 마찬가지로 값을 선언하여 사용할 수 있다
- Math 클래스: 수학계산에 사용할 기능을 가지고 잇는 객체


14. 컬렉션 프레임워크
- 컬렉션 프레임워크: 컬렉션 프레임워크는 데이터를 다룰 때 자주 사용되는 주요 자료구조를 말한다 컬렉션은 기존의 List, Map, Set등의 자료구조를 뜻 하고 프레임워크는 클래스와 인터페이스를 묶어놓은 개념

- List 컬렉션: 배열과 비슷하게 index로 객체를 관리한다, 다만 배열과 다르게 크기의 제한이 없으며 삽입, 삭제, 변경의 기능이 자유롭다 List에는 대표적으로 ArrayList와 LinkedList가 있다

- ArrayList: 데이터를 순차적으로 저장한다 데이터가 삽입될 때마다 크기가 증가하고 배열을 삭제하면 공간이 줄어든다 index를 기준으로 값을 삽입하거나 추출한다

- LinkedList: Node객체를 기반으로 데이터를 저장한다 Node객체는 데이터와 자신 다음에 올 데이터의 주소를 값으로 가진다

- Set 컬렉션: Set 컬렉션은 LIst컬렉션과 다르게 객체의 저장순서를 저장하지 않으며, 데이터의 중복을 허용하지 않는다 또한 데이터를 저장할 때 index를 부여하지 않기 때문에, 데이터가 입력된 순서로 출력된다는 보장이 없다 대표적으로 HashSet가 있다

- Map 컬랙션:  Map컬렉션은 List, Set컬렉션과 달리 Map interface가 별도로 존재하며 데이터를 List계열의 커렉션과 다르게 처리한다 Map는 key의 중복을 허용하지 않는다 만약 key가 중복된다면 기존에 있던
key에 해당하는 value값이 마지막으로 등록된 값으로 치환된다, 대표적으로 Map을 상속받아 구현한 HashMap, TreeMap, LinkedHashMap이 있다
()
- HashMap/HashSet: HashSet 또는 HashMap은 객체 데이터를 value 또는 key로 할 경우, 중복 객체 체크를 위해 해당 객체의 hashCode()와 equals()메소드를 오버라이딩하여 구현해야한다

15. 람다식
- 람다식 : JDK 1.8부터 자바에서 지원하는 함수형 프로그래밍을 람다식이라고 한다 람다식은 함수의 이름이 없는 익명함수를 만들기위한 표현식이다

- 람다식은 익명함수답게 메서드이 이름과 반환 타입을 제거하고 화살표 -> 기호로 사용해 구현한다
- 람다식 선언: 람다식을 사용하기 위해서는 함수형 인터페이스를 선언한다, 함수형 인터페이슨는 익명함수와 매개변수만 구현되기 때문에 하나의 메서드만 가져야한다
- @FanctiionallInterface 어노테이션을 사용해 메서드 두개 이상 선언 하는 개발자의 실수를 방지할수 있습니다




	




























