day09

복습 -> 2차원 배열 -> 메소드

0. 복습
1) 배열
	하나의 타입으로 여러개의 값을 저장할 수 있는 저장공간

2) 배열의 사용 목적
	데이터의 집합을 효율적으로 관리하기 위한 목적
	데이터의 순서를 보존하기 위한 목적
	반복문을 사용하여 배열의 요소를 처리하기 위한 목적
	메모리를 효율적으로 사용하기 위한 목적
	데이터를 정렬하거나 검색하기 위한 목적

3) 배열의 선언
- 배열변수의 선언
	자료형[] 참조변수;
	자료형 참조변수[];

- 배열의 생성과 초기화
	자료형[] 참조변수 = new 자료형[];
	자료형[] 참조변수 = new 자료형[]{값1, 값2, 값3, ...};
	자료형[] 참조변수 = {값1, 값2, 값3, ..};

4) 배열의 구조
	int[]	ar	=	new	int[3];
	
	-----------		----------------
	Srack영역			Heap 영역
	[첫번째 주소값]		[값1][값2][값3]
	ar			   0   1    2	=> 인덱스 번호

-----------------------------------------------------------------------
1. for~each문(빠른 for문, 확장 for문)
	배열이나 컬렉션을 순회할 때 사용하는 반복문
	요소의 타입과 변수명을 지정하여 간편하게 순회 가능

	// 일반 for문
	for(초기식; 조건식; 증감식){
	
	}

	// for~each문
	for(요소의 타입 변수명 : 배열 또는 컬렉션){
		// 요소에 대한 작업 수행
	}

1) for-each문 특징
	배열 또는 컬렉션의 모든 요소를 차례대로 접근
	요소를 수정할 수 없음(읽기 전용)
	인덱스 사용 불가능
	요소의 타입은 배열 또는 컬렉션의 타입과 일치해야함

2. 2차원 배열
	배열 안에 배열
	※ 2차원 이상의 배열은 메모리 낭비가 심하므로 선호하지 않는다
	표 형태의 데이터를 저장할 때 주로 사용
	자바에서는 2차원 배열도 1차원 배열의 배열이기 때문에 행마다 열의 길이가 다를 수 있음(가변배열)

1) 2차원 배열 선언
	자료형[][] 배열명 = new 자료형[행][열];
	10 20 30
	40 50 60
	자료형[][] 배열명 = {{값1, 값2, 값3},{값4, 값5, 값6}};

2) 2차원 배열 길이
	배열명.length; 행의 길이
	배열명[i].length; 열의 길이


3. 정렬 알고리즘
	데이터를 정해진 순서대로 정렬하는 방법
	
1) 정렬 알고리즘 종류
	알고리즘 		시간복잡도(평균)	공간복잡도		특징
	선택정렬		O(n²)		O(1)		가장 작은 값 선택 앞으로 이동
	삽입정렬		O(n²)		O(1)		거의 정렬된 경우 빠름
	버블정렬		O(n²)		O(1)		가장 간단, 인접한 요소 비교
	퀵정렬		O(n log n)	O(log n)	분할 정복 방식
	병합정렬		O(n log n)	O(n)		리스트 합병
	힙정정렬		O(n log n)	O(1)		최대/최소 힙 자료구조 사용
	계수정렬		O(n + k)	O(n + k)	정수범위 작을 때 매우 빠름

2) 선택 정렬(Selection Sort)
	현재 위치에서 가장 작은 값을 찾아 앞으로 보냄
- 동작원리
	배열에서 가장 작은 값을 찾아 현재 위치로 이동한다
	다음위치에서 가장 작은 값을 찾아 이동한다
	마지막까지 반복한다

3) 삽입 정렬(Insertion Sort)
	정렬된 영역에 하나씩 끼워넣음
- 동작원리
	두번째 요소부터 시작하여 이전 요소들과 비교한다
	비교를 통해 자신의 위치를 찾은 후 그 자리에 삽입한다
	나머지 요소를 반복적으로 처리한다

4) 버블 정렬(Bubble Sort)
	인접한 두값을 비교해서 swap(교환)
- 동작원리
	반복적으로 배열을 순회하며 인접한 두 요소 비교한다
	두 요소의 순서가 잘못되었다면 교환(swap)한다
	각 반복이 끝날 때 가장 큰 요소는 배열의 끝으로 이동하여 정렬된 상태가 된다
	마지막 정렬된 요소를 제외하고 나머지 요소를 비교하고 정렬한다
	배열이 완전히 정렬될 때까지 이 과정을 반복한다

5) Array.sort()
	java.util.Array 클래스에 포함된 정렬 메소드
	내부적으로 TimSort 알고리즘을 사용하며 합병정렬과 삽입 정렬을 결합한 고효율 알고리즘이다
	기본적으로 오름차순으로 정렬되며 배열을 빠르고 효율적으로 정렬 할 수 있다

+) Arrays.toString(배열명)
	.toString() 배열의 내용을 문자열 형식으로 반환하는 메소드
	배열을 보기 쉽게 출력하기 위해 사용한다
	기본적으로 1차원 배열의 내용을 출력할 수 있다


4. 메소드
0) 함수와 메소드
	클래스 밖에 선언되어 있다면 함수라고 부르지만 클래스 내부에 선언되어있는 함수는 메소드라고 부른다
	자바에서는 모든 함수가 클래스 내부에서 선언되기 때문에 메소드만 존재한다
	자바에서는 메소드라고 부른다

1) 메소드(method)
	기능
	이름 뒤에 소괄호
	키워드 뒤에 소괄호는 메소드라고 부르지 않는다
	
2) 메소드 선언과 구현(정의)
	리턴타입 메소드명(자료형 매개변수, ...) <- 선언부
	{				<- 구현부
		실행할문장;
		return 리턴갑시;
	}

- 리턴타입: 반환할 값이 있다면 반환값의 자료형을 작성한다. 없다면 void를 작성한다
- 메소드명: 동사로 작성한다
- 매개변수: 외부에서 전달받을 값이 있다면 자료형과 순서에 맞게 선언해준다(자료형이 반드시 필요하다)
	생략이 가능하다(단, 생략하게 되면 외부에서 값을 받을 수 없다)
- 실행할문장: 생략이 가능하다. 메소드의 기능을 구현하는 코드를 작성한다
- return: 생략이 가능하다. return이 실행되면 메소드가 종료된다.
	리턴값이 있다면 메소드를 사용한 부분을 통채로 리턴값으로 본다.
	리턴값이 없다면 값이 아니다.

3) 메소드의 정의와 사용
	메소드를 정의할 때는 {}중괄호가 있고, 반드시 메소드 밖에서 정의한다
	메소드를 사용할 때는 {}중괄호가 없고, 반드시 메소드 안에서 사용한다

+) 메소드를 정의한 후 메소드를 호출 할 때 오류나는 이유
	java 어플리케이션을 실행하면 .java파일을 컴파일러가 해석하고  .class 파일을 만들어준다
	.class 파일을 JVM에 포함된 클래스 로더가 읽어내는데 static이 붙은 변수나 메소드를 먼저 메모리에 할당시킨다

	int add(int num1, int num2){
		int result = num1 + num2
		return result;
	}
	이상태는 메모리에 올라가지 않은 상태이기 때문에 add라는 메소드를 못찾아서 오류가 발생한다

- 	메소드를 정의할 때 static 키워드를 붙여준다
- 	클래스명 참조변수 = new 클래스명();
	해당 메소드가 있는 클래스를 알려준다
	참조변수명.메소드명(); 형태로 사용하면 된다.


4) 메소드 정의 순서
	기능을 생각한다(숫자에 10을 더하는 기능)
	1. 반환타입을 생각한다. 우선 void라고 작성한다
		void
	2. 기증에 알맞은 메소드명을 생각한다(addTen)
		void addTen
	3. 매개변수를 생각한다(정수형 매개변수1)
		void adTen(int num)	<- 선언부
		{}			<- 구현부
	4. 실행할 문장을 생각한다
	   숫자 + 10
		void addTen(int num){
			int result = num +10;
		}
	5. 리턴값을 생각한다
		void addTen(int num){
			int result = num + 10;
			return result;
		}
	6. 리턴값에 맞는 반환타입을 수정한다
		int addTen(int num){
			int result = num + 10;
			return result;
		}

5) 메소드 호출 방법(메소드 사용)
	매개변수 리턴값(반환값)	   호출방법
	x	x		=> 메소드명();
	o	x		=> 메소드명(인수);
	x	o		=> syso(메소드명()); or 리턴값의타입 변수명 = 메소드명();
	o	o		=> syso(메소드명(인수)); or 리턴값의타입 변수명 = 메소드명(인수);